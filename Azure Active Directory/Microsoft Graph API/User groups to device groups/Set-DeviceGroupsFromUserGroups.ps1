<#PSScriptInfo

.VERSION 1.0

.DATE 02-Jul-2023

.AUTHOR adrian.cojocaru

#>

<#
  .SYNOPSIS
  Updates an the membership of an Azure AD device group based of a membership of an user group

  .DESCRIPTION
  Name and AzureAD Object IDs for the device & user group are defined inside the configuration file (JSON format). See Set-DeviceGroupsFromUserGroups.json
  The script will first check if the Id matches the name of each group (safeguard).
  When running, the membership of the DeviceAzureADGroupId will be updated with the devices owned by users in UserAzureADGroupId.
  e.g if a user is added to the UserAzureADGroupId then the script will add their devices to the DeviceAzureADGroupId
  if a user is removed from the UserAzureADGroupId then the script will remove their devices from the DeviceAzureADGroupId
  App registration permissions:
  Microsoft Graph (3)	
    Device.Read.All
    GroupMember.ReadWrite.All
    User.Read.All 

  .INPUTS
  If your script accepts pipeline input, describe it here.

  .OUTPUTS
  output generated by your script. If any.

  .EXAMPLE
  .\Set-DeviceGroupsFromUserGroups.ps1

#>


#Region ----------------------------------------------------- [AzureAD Variables] ----------------------------------------------
[string]$tenantId = if ($env:AZUREPS_HOST_ENVIRONMENT) { Get-AutomationVariable -Name "TenantId" } else { $env:TenantId }
[string]$clientId = if ($env:AZUREPS_HOST_ENVIRONMENT) { Get-AutomationVariable -Name "UserToDeviceGroupsAppClientId" } else { $env:UserToDeviceGroupsAppClientId }
[string]$appSecret = if ($env:AZUREPS_HOST_ENVIRONMENT) { Get-AutomationVariable -Name "UserToDeviceGroupsAppSecret" } else { $env:UserToDeviceGroupsAppSecret }
#[string]$JsonPath = "C:\GitRepos\AzureAD\GraphAPI\User groups to device groups\Set-DeviceGroupsFromUserGroups.json"

[string]$JsonPath = "https://StorageAccount.blob.core.windows.net/testac/Set-DeviceGroupsFromUserGroups.json?%3D"
#EndRegion -------------------------------------------------- [AzureAD Variables] ----------------------------------------------
#Region ----------------------------------------------------- [Script Variables] ----------------------------------------------
[version]$ScriptVersion = [version]'1.0.0'
$Global:ExitCode = 0
$Global:GraphTokenRefreshLimit = 24
$Global:GraphTokenRefreshCount = 0
$VerbosePreference = "SilentlyContinue"
$TimeStamp = get-date -Format yyyyMMddTHHmmss
#EndRegion -------------------------------------------------- [Script Variables] ----------------------------------------------
#Region ----------------------------------------------------- [Classes] ----------------------------------------------
class CustomException : Exception {
    <#

    .DESCRIPTION
    Used to throw exceptions.
    .EXAMPLE
    throw [CustomException]::new( "Get-ErrorOne", "This will cause the script to end with ExitCode 101")

#>
    [string] $additionalData

    CustomException($Message, $additionalData) : base($Message) {
        $this.additionalData = $additionalData
    }
}
#EndRegion -------------------------------------------------- [Classes] ----------------------------------------------
#Region ----------------------------------------------------- [Functions] ----------------------------------------------
Function Write-LogRunbook {
    <#

    .DESCRIPTION
    Write messages to a log file defined by $LogPath and also display them in the console.
    Message format: [Date & Time] [CallerInfo] :: Message Text

#>
    [CmdletBinding()]
    Param (
        [Parameter(Mandatory = $true, Position = 0, ValueFromPipeline = $true)]
        [ValidateNotNull()]
        [AllowEmptyString()]
        # Mandatory. Specifies the message string.
        [string]$Message,
        [Parameter(Mandatory = $false, Position = 1)]
        [ValidateNotNull()]
        # Optional. Specifies the name of the message writter. Function, command or custom name. Defaults to FunctioName or unknown
        [string]$Caller = 'Unknown',
        [Parameter(Mandatory = $false, Position = 2)]
        [AllowEmptyCollection()]
        # Optional. This parameter is not needed. it is here soleley for backwards compatibility with Write-Error2
        [array]$Color
    )
    Begin {
        [string]$LogDate = (Get-Date -Format 'MM-dd-yyyy').ToString()
        [string]$LogTime = (Get-Date -Format 'HH\:mm\:ss.fff').ToString()
        #if ([string]::IsNullOrEmpty($Message)) { return }
    }
    Process {
        "[$LogDate $LogTime] [${Caller}] :: $Message" | Write-Verbose -Verbose  
    }
    End {}
}

function Write-ErrorRunbook {
    [CmdletBinding()]
    Param (
        [Parameter(Mandatory = $false, Position = 0)]
        [AllowEmptyCollection()]
        # Optional. The errorr collection.
        [array]$ErrorRecord
    )
    Begin {
        [string]${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name
        If (-not $ErrorRecord) {
            If ($global:Error.Count -eq 0) {
                Return
            }
            Else {
                [array]$ErrorRecord = $global:Error[0]
            }
        }
    }
    Process {
        $ErrorRecord | ForEach-Object {
            $errNumber = $ErrorRecord.count - $( $ErrorRecord.IndexOf($_))
            $ErrorText = "[${CmdletName} Nr. $errNumber] :: $($($_.Exception).Message)`n" + `
                ">>> Line: $($($_.InvocationInfo).ScriptLineNumber) Char: $($($_.InvocationInfo).OffsetInLine) <<<`n" + `
                "$($($_.InvocationInfo).Line)" 
            $ErrorText | Write-Error
        }
    }
    End {}
}

function  Get-GraphToken {
    Begin {
        [string]${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name
        $PSBoundParameters.GetEnumerator() | Sort-Object -Property Name | ForEach-Object { "$($_.Key) = $($_.Value)" | Write-LogRunbook -Caller $CmdletName }
    }
    End {
        try {
            $GraphUrl = "https://login.microsoftonline.com/$tenantid/oauth2/v2.0/token"
            $body = @{
                Grant_Type    = "client_credentials"
                Scope         = "https://graph.microsoft.com/.default"
                Client_Id     = $clientId
                Client_Secret = $appSecret
            }
              
            $connection = Invoke-RestMethod -Method Post -Uri $GraphUrl -Body $body -ErrorAction Stop
            $connection.access_token
        }
        catch {
            Write-ErrorRunbook
            throw [CustomException]::new( $CmdletName, "Error calling $GraphUrl")
        }
    } 
}

function Get-JsonContent {
    param (
        [Parameter(Mandatory = $false, Position = 0, ValueFromPipeline = $true)]
        [ValidateNotNull()]
        [AllowEmptyString()]
        # Mandatory. Specifies the message string.
        [string]$JsonFilePath,
        [Parameter(Mandatory = $false, Position = 1)]
        [ValidateNotNull()]
        [AllowEmptyString()]
        # Mandatory. Specifies the message string.
        [switch]$Web
    )
    Begin {
        [string]${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name
        $PSBoundParameters.GetEnumerator() | Sort-Object -Property Name | ForEach-Object { "$($_.Key) = $($_.Value)" | Write-LogRunbook -Caller $CmdletName }
    }
    End {
        try {
            if ($Web) {
                #Invoke-RestMethod 'https://stfnemeamemtransfer.blob.core.windows.net/testac/AdvancedHuntingTestQueries.json?sp=r&st=2023-08-06T19:49:39Z&se=2024-08-07T03:49:39Z&spr=https&sv=2022-11-02&sr=b&sig=3RlsQZ6vTbur%2F6T4YPDK7izF525uobv4zCJbZypjp4M%3D' -ErrorAction Stop
                Invoke-RestMethod $JsonFilePath -ErrorAction Stop
            }
            else {
                Get-Content $JsonPath -Raw | ConvertFrom-Json 
            }
        }
        catch {
            Write-ErrorRunbook
            throw [CustomException]::new( $CmdletName, "Error reading the json file. Check if the file exists and it is a valid json format.")
        }
    }
}

function  Test-AADGroup {
    <#
  .DESCRIPTION
  Check if the AzureAD group exists and the Id matches the name.
  This is a safeguard in case of mistakes in the config file
 .Example
   Test-AADGroup -AADGroupObjectId '0ed6c216-dde9-4a06-83fe-923f1e42c86a' -GroupName 'TestAADGroup1'
#>
    param (
        [Parameter(Mandatory = $true, Position = 0, ValueFromPipeline = $true)]
        [ValidateNotNull()]
        [AllowEmptyString()]
        # Mandatory. Specifies the message string.
        [string]$AADGroupObjectId,
        [Parameter(Mandatory = $true, Position = 0, ValueFromPipeline = $true)]
        [ValidateNotNull()]
        [AllowEmptyString()]
        # Mandatory. Specifies the message string.
        [string]$GroupName
    )
    Begin {
        [string]${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name
        $PSBoundParameters.GetEnumerator() | Sort-Object -Property Name | ForEach-Object { "$($_.Key) = $($_.Value)" | Write-LogRunbook -Caller $CmdletName }
    }
    End {
        try {
            $headers = @{ 'Authorization' = "Bearer $Token_Graph" }
            $url = "https://graph.microsoft.com/v1.0/groups/$AADGroupObjectId"
            $response = Invoke-WebRequest -Uri $url -Headers $headers -Method Get -UseBasicParsing -ErrorAction Stop
            $GroupInfo = $response.Content | ConvertFrom-Json
            #check this when the group will have a few members..
            if ($GroupInfo.displayName -eq $GroupName) {
                Write-LogRunbook 'Group Name & Id match.' -Caller $CmdletName
                return $true
            }
            else {
                Write-LogRunbook "The provided Group name: '$GroupName' doesn't match the actual Group display name: '$($GroupInfo.displayName)' for GroupId: '$AADGroupObjectId'." -Caller $CmdletName
                return $false
            }
        }
        catch {
            switch ($_.Exception.Response.StatusCode) {
                'Unauthorized' {
                    if ($Global:GraphTokenRefreshCount -lt $Global:GraphTokenRefreshLimit) {
                        Write-LogRunbook "Token expired. Getting a new one. GraphTokenRefreshCount: '$Global:GraphTokenRefreshCount'" -Caller $CmdletName
                        $global:Token_Graph = Get-GraphToken
                        $Global:GraphTokenRefreshCount++
                        Get-AADTransitiveGroupMembers @PSBoundParameters
                    }
                    else {
                        Write-ErrorRunbook
                        throw [CustomException]::new( $CmdletName, "GraphTokenRefreshLimit '$Global:GraphTokenRefreshCount' reached! ")
                    }
                }
                'NotFound' { 
                    Write-LogRunbook "AzureAD object not found." -Color DarkYellow -Caller $CmdletName
                }
                Default {
                    Write-ErrorRunbook
                    throw [CustomException]::new( $CmdletName, "$($response.StatusCode) StatusCode calling '$url'")
                }
            }
        }
    } 
}

function Get-AADTransitiveGroupMembers {
    <#
.DESCRIPTION
  Returns a flat list of all nested users that are members of an AzureAD group.
  Either users or devices. The other types will probably also work but it is yet to be tested.

.PARAMETER MemberType
  The values for this parameetr can only be microsoft.graph.device or microsoft.graph.user
  The other types will probably also work but it is yet to be tested.

.Example
   Get-AADTransitiveGroupMembers -AADGroupObjectId 'wwwwwwwww' -MemberType 'microsoft.graph.device'

.Example
   Get-AADTransitiveGroupMembers -AADGroupObjectId 'wwwwwwwww' -MemberType 'microsoft.graph.user'
#>
    param (
        [Parameter(Mandatory = $true, Position = 0, ValueFromPipeline = $true)]
        [ValidateNotNull()]
        [AllowEmptyString()]
        # Mandatory. Specifies the message Object id of the Azure AD group.
        [string]$AADGroupObjectId,
        [Parameter(Mandatory = $true, Position = 0, ValueFromPipeline = $false)]
        [ValidateNotNull()]
        [AllowEmptyString()]
        # Mandatory. Specifies the message Object id of the Azure AD group.
        [string][ValidateSet('microsoft.graph.device', 'microsoft.graph.user')]$MemberType
    )
    Begin {
        [string]${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name
        #$AlreadyAddedList = [System.Collections.ArrayList]::new()
        $MembersList = @()
    }
    Process {
        try {
            $PSBoundParameters.GetEnumerator() | Sort-Object -Property Name | ForEach-Object { "$($_.Key) = $($_.Value)" | Write-LogRunbook -Caller $CmdletName }
            $headers = @{
                Authorization  = "Bearer $Token_Graph"
                "Content-type" = "application/json"
            }
            #$url1 = "https://graph.microsoft.com/v1.0/groups/$AADGroupObjectId/transitiveMembers?`$filter=isof('microsoft.graph.user')"
            $url = "https://graph.microsoft.com/v1.0/groups/$AADGroupObjectId/transitiveMembers/$MemberType`?`$select=id"
            $responseGR = Invoke-RestMethod -Headers $headers -Uri $url -Method Get -ErrorAction Stop
            if ($responseGR.value) { $MembersList += $responseGR.value }
            while ($responseGR.'@odata.nextLink') {
                $responseGR = Invoke-RestMethod -Headers $headers -Uri $responseGR.'@odata.nextLink' -Method Get -ErrorAction Stop
                if ($responseGR.value) { $MembersList += $responseGR.value }
            }
            $MembersList.id
        }
        catch {
            switch ($_.Exception.Response.StatusCode) {
                'Unauthorized' {
                    if ($Global:GraphTokenRefreshCount -lt $Global:GraphTokenRefreshLimit) {
                        Write-LogRunbook "Token expired. Getting a new one. GraphTokenRefreshCount: '$Global:GraphTokenRefreshCount'" -Caller $CmdletName
                        $global:Token_Graph = Get-GraphToken
                        $Global:GraphTokenRefreshCount++
                        Get-AADTransitiveGroupMembers @PSBoundParameters
                    }
                    else {
                        Write-ErrorRunbook
                        throw [CustomException]::new( $CmdletName, "GraphTokenRefreshLimit '$Global:GraphTokenRefreshCount' reached! ")
                    }
                }
                'NotFound' { 
                    Write-LogRunbook "AzureAD object not found." -Color DarkYellow -Caller $CmdletName
                }
                Default {
                    Write-ErrorRunbook
                    throw [CustomException]::new( $CmdletName, "$($response.StatusCode) StatusCode calling '$url'")
                }
            }
        }
    }
    End {
        # Write-Log "Ended" -Caller $CmdletName
    }
}
function Get-AADUserOwnedDevices {
    <#
  .DESCRIPTION
  Returns a flat list of all owned by an AzureAD user

 .Example
   Get-AADTransitiveGroupMembers -AADGroupId 'wwwwwwwww'
#>
    param (
        [Parameter(Mandatory = $true, Position = 0, ValueFromPipeline = $true)]
        [ValidateNotNull()]
        [AllowEmptyString()]
        # Mandatory. Specifies the message Object id of the Azure AD group.
        [string]$AADUserObjectId,
        [Parameter(Mandatory = $false, Position = 1, ValueFromPipeline = $false)]
        [ValidateNotNull()]
        [AllowEmptyString()]
        # Mandatory. Specifies the message Object id of the Azure AD group.
        [string[]]$OSes
    )
    Begin {
        [string]${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name
        #$AlreadyAddedList = [System.Collections.ArrayList]::new()
        $MembersList = @()
    }
    Process {
        try {
            $PSBoundParameters.GetEnumerator() | Sort-Object -Property Name | ForEach-Object { "$($_.Key) = $($_.Value)" | Write-LogRunbook -Caller $CmdletName }
            $headers = @{
                Authorization  = "Bearer $Token_Graph"
                "Content-type" = "application/json"
            }
            #$url1 = "https://graph.microsoft.com/v1.0/groups/$AADGroupId/transitiveMembers?`$filter=isof('microsoft.graph.user')"
            $url = "https://graph.microsoft.com/v1.0/users/$AADUserObjectId/ownedDevices?`$select=id,displayName,operatingSystem,deviceId"
            
            #"https://graph.microsoft.com/v1.0/users/$AADUserObjectId/ownedDevices?`$filter=operatingSystem eq 'Windows'"
            #The specified filter to the reference property query is currently not supported."
            $responseGR = Invoke-RestMethod -Headers $headers -Uri $url -Method Get -ErrorAction Stop
            if ($responseGR.value) {
                if ($OSes.count) {
                    $MembersList += $responseGR.value | Where-Object -Property operatingSystem -in -value $OSes
                }
                else {
                    $MembersList += $responseGR.value 
                }
            }
            while ($responseGR.'@odata.nextLink') {
                $responseGR = Invoke-RestMethod -Headers $headers -Uri $responseGR.'@odata.nextLink' -Method Get -ErrorAction Stop
                if ($responseGR.value) { $MembersList += $responseGR.value }
            }
            $MembersList
        }
        catch {
            switch ($_.Exception.Response.StatusCode) {
                'Unauthorized' {
                    if ($Global:GraphTokenRefreshCount -lt $Global:GraphTokenRefreshLimit) {
                        Write-LogRunbook "Token expired. Getting a new one. GraphTokenRefreshCount: '$Global:GraphTokenRefreshCount'" -Caller $CmdletName
                        $global:Token_Graph = Get-GraphToken
                        $Global:GraphTokenRefreshCount++
                        Get-AADUserOwnedDevices @PSBoundParameters
                    }
                    else {
                        Write-ErrorRunbook
                        throw [CustomException]::new( $CmdletName, "GraphTokenRefreshLimit '$Global:GraphTokenRefreshCount' reached! ")
                    }
                }
                'NotFound' { 
                    Write-LogRunbook "AzureAD object not found." -Color DarkYellow -Caller $CmdletName
                }
                Default {
                    Write-ErrorRunbook
                    throw [CustomException]::new( $CmdletName, "$($response.StatusCode) StatusCode calling '$url'")
                }
            }
        }
    }
    End {
        # Write-Log "Ended" -Caller $CmdletName
    }
}
function  Add-AADGroupMembers {
    <#

.DESCRIPTION
  Adds one or more members to an AzureAD group.

.PARAMETER MemberType
  One or more AzureAD Object IDs that you want added.
  Careful what you put here :)
#>
    param (
        [Parameter(Mandatory = $true, Position = 0, ValueFromPipeline = $false)]
        [ValidateNotNull()]
        [AllowEmptyString()]
        # Mandatory. Specifies the message string.
        [string]$AADGroupObjectId,
        [Parameter(Mandatory = $true, Position = 1, ValueFromPipeline = $true)]
        [ValidateNotNull()]
        [AllowEmptyString()]
        # Mandatory. One or more AzureAD Object IDs that you want added.
        [string[]]$AADObjectIds
    )
    Begin {
        [string]${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name
        $PSBoundParameters.GetEnumerator() | Sort-Object -Property Name | ForEach-Object { "$($_.Key) = $($_.Value)" | Write-LogRunbook -Caller $CmdletName }
        #$urlref = "https://graph.microsoft.com/v1.0/groups/$AADGroupObjectId/members/`$ref"
        $urlMultiObj = "https://graph.microsoft.com/v1.0/groups/$AADGroupObjectId"
        $headers = @{
            Authorization  = "Bearer $Token_Graph"
            "Content-type" = "application/json"
        }
    }
    Process {
        #Write-LogRunbook "Next batch of ObjectIds:" -Caller $CmdletName # comment this later on
        #$ObjectIds | Out-String | Write-LogRunbook -Caller $CmdletName # comment this later on
    }
    End {
        try {
            #Note that up to 20 members can be added in a single request
            # https://learn.microsoft.com/en-us/graph/api/group-post-members?view=graph-rest-1.0&tabs=http
            $CurrentCount = 0
            $ObjIdsToBeAdded = New-Object System.Collections.Generic.List[System.Object]
            $AADObjectIds | ForEach-Object { $ObjIdsToBeAdded.Add("https://graph.microsoft.com/v1.0/directoryObjects/$_") }
            while ($CurrentCount -lt $AADObjectIds.count) {
                $body = @{}
                $NewCount = $CurrentCount + 19
                Write-LogRunbook "Batch of objects to be added:" -Caller $CmdletName
                $ObjIdsToBeAdded[$CurrentCount..$NewCount] | Out-String | Write-LogRunbook -Caller $CmdletName   
                $body.Add("members@odata.bind", $ObjIdsToBeAdded[$CurrentCount..$NewCount])
                $bodyJSON = $body | ConvertTo-Json
                $response = Invoke-RestMethod -Headers $headers -Uri $urlMultiObj -Method Patch -Body $bodyJSON -ErrorAction Stop
                #Write-LogRunbook "$($AADObjectIds.count) objects added. StatusCode = $($response.StatusCode)" -Caller $CmdletName
                Write-LogRunbook "Objects successfully added." -Caller $CmdletName
                $CurrentCount = $NewCount + 1
            }
        }
        catch {
            switch ($_.Exception.Response.StatusCode) {
                'Unauthorized' {
                    if ($Global:GraphTokenRefreshCount -lt $Global:GraphTokenRefreshLimit) {
                        Write-LogRunbook "Token expired. Getting a new one. GraphTokenRefreshCount: '$Global:GraphTokenRefreshCount'" -Caller $CmdletName
                        $global:Token_Graph = Get-GraphToken
                        $Global:GraphTokenRefreshCount++
                        Add-AADGroupMembers @PSBoundParameters
                    }
                    else {
                        Write-ErrorRunbook
                        throw [CustomException]::new( $CmdletName, "GraphTokenRefreshLimit '$Global:GraphTokenRefreshCount' reached! ")
                    }
                }
                'NotFound' { 
                    Write-LogRunbook "AzureAD object not found." -Color DarkYellow -Caller $CmdletName
                }
                Default {
                    Write-ErrorRunbook
                    throw [CustomException]::new( $CmdletName, "$($response.StatusCode) StatusCode calling '$url'")
                }
            }
        }
    }
}
function  Remove-AADDirectGroupMember {
    <#

.DESCRIPTION
  Removes a member direct from an AzureAD group.
  e.g. If Objects are part of a group that is member of our group, they can't be removed individually

#>
    param (
        [Parameter(Mandatory = $true, Position = 0, ValueFromPipeline = $false)]
        [ValidateNotNull()]
        [AllowEmptyString()]
        # Mandatory. Specifies the message string.
        [string]$AADGroupObjectId,
        [Parameter(Mandatory = $true, Position = 1, ValueFromPipeline = $true)]
        [ValidateNotNull()]
        [AllowEmptyString()]
        # Mandatory. Specifies the message string.
        [string]$ObjectId
    )
    Begin {
        [string]${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name
        #$urlref = "https://graph.microsoft.com/v1.0/groups/$AADGroupObjectId/members/`$ref"
        $headers = @{
            Authorization  = "Bearer $Token_Graph"
            "Content-type" = "application/json"
        }
    }
    Process {
        try {
            $PSBoundParameters.GetEnumerator() | Sort-Object -Property Name | ForEach-Object { "$($_.Key) = $($_.Value)" | Write-LogRunbook -Caller $CmdletName }
            $url = "https://graph.microsoft.com/v1.0/groups/$AADGroupObjectId/members/$ObjectId/`$ref"
            Write-LogRunbook "Removing $url" -Caller $CmdletName
            $response = Invoke-RestMethod -Headers $headers -Uri $url -Method Delete -ErrorAction Stop
        }
        catch {
            switch ($_.Exception.Response.StatusCode) {
                'Unauthorized' {
                    if ($Global:GraphTokenRefreshCount -lt $Global:GraphTokenRefreshLimit) {
                        Write-LogRunbook "Token expired. Getting a new one. GraphTokenRefreshCount: '$Global:GraphTokenRefreshCount'" -Caller $CmdletName
                        $global:Token_Graph = Get-GraphToken
                        $Global:GraphTokenRefreshCount++
                        Remove-AADDirectGroupMember @PSBoundParameters
                    }
                    else {
                        Write-ErrorRunbook
                        throw [CustomException]::new( $CmdletName, "GraphTokenRefreshLimit '$Global:GraphTokenRefreshCount' reached! ")
                    }
                }
                'NotFound' { 
                    Write-LogRunbook "Object Id '$ObjectId' not found." -Color DarkYellow -Caller $CmdletName
                }
                Default {
                    Write-ErrorRunbook
                    throw [CustomException]::new( $CmdletName, "$($response.StatusCode) StatusCode calling '$url'")
                }
            }
        }
    }
    End {
    }
}
#EndRegion -------------------------------------------------- [Functions] ----------------------------------------------
#Region -------------------------------------------------------- [Main] ----------------------------------------------
try {
   
    "====================================================================" | Write-LogRunbook -Caller 'Info-Start'
    "======================= ScriptVersion: $Scriptversion =======================" | Write-LogRunbook -Caller 'Info-Start'
    $PSBoundParameters.GetEnumerator() | Sort-Object -Property Name | ForEach-Object { "$($_.Key) = $($_.Value)" |  Write-LogRunbook -Caller 'Info-Start' }
    $CurrentJsonObject = 1
    $JsonObjects = Get-JsonContent -JsonFilePath $JsonPath -Web
    $Token_Graph = Get-GraphToken
    $JsonObjects | ForEach-Object {
        Write-LogRunbook "--------------------------------------------------------------------------------" -Caller "JsonEntry $CurrentJsonObject"
        #        Write-LogRunbook "Processing AzureAD Group: '$($_.AzureADGroupName)' Id: '$($_.AzureADGroupId)'" -Caller "JsonEntry $CurrentJsonObject"
        if ((Test-AADGroup -AADGroupObjectId $_.UserAzureADGroupId -GroupName $_.UserAzureADGroupName) -and
            (Test-AADGroup -AADGroupObjectId $_.DeviceAzureADGroupId -GroupName $_.DeviceAzureADGroupName)) {
            #validating if OS list consist valid OS
            $PossibleOsList = "Windows", "MacOS", "IPhone", "IPad", "Android"
            $OSlist = $_.OSList -split ','
            if (-not (Compare-Object -ReferenceObject $PossibleOsList -DifferenceObject $OSList | Where-Object { $_.SideIndicator -eq '=>' })) {
                $UserAssignedDevices = Get-AADTransitiveGroupMembers -AADGroupObjectId $_.UserAzureADGroupId -MemberType 'microsoft.graph.user' | Get-AADUserOwnedDevices -OSes $OSlist
                if ($UserAssignedDevices) {
                    $UniqueDevicesToBeAdded = ($UserAssignedDevices | Group-Object -Property id).Name
                    $DestinationGroupExistingDevices = Get-AADTransitiveGroupMembers -AADGroupObjectId $_.DeviceAzureADGroupId -MemberType 'microsoft.graph.device'
                    #adding devices to group
                    if ($DestinationGroupExistingDevices.Count -eq 0) {
                        Add-AADGroupMembers -AADObjectIds $UniqueDevicesToBeAdded -AADGroupObjectId "$($_.DeviceAzureADGroupId)"
                        #$UniqueDevicesToBeAdded | Out-String | Write-Output
                        Write-Output "Added $($UniqueDevicesToBeAdded.count) devices to group '$($_.DeviceAzureADGroupName)'. Source group: '$($_.UserAzureADGroupName)'"
                    }
                    else {
                        # difference between t1wo groups, to remove/add elements
                        $Differences = Compare-Object -ReferenceObject $DestinationGroupExistingDevices -DifferenceObject $UniqueDevicesToBeAdded
                        $ObjToBeAdded = ($Differences | Where-Object { $_.SideIndicator -eq '=>' }).InputObject
                        $ObjToBeRemoved = ($Differences | Where-Object { $_.SideIndicator -eq '<=' }).InputObject
                        if ($ObjToBeAdded) {
                            Add-AADGroupMembers -AADObjectIds $ObjToBeAdded -AADGroupObjectId $_.DeviceAzureADGroupId
                        }
                        if ($ObjToBeRemoved) {
                            $ObjToBeRemoved | Remove-AADDirectGroupMember -AADGroupObjectId $_.DeviceAzureADGroupId
                        }
                        $ObjToBeAdded | Out-String | Write-Output
                        Write-Output "Added $($ObjToBeAdded.count) objects to group '$($_.DeviceAzureADGroupName)'. Source group: '$($_.UserAzureADGroupName)'"
                        $ObjToBeRemoved | Out-String | Write-Output
                        Write-Output "Removed $($ObjToBeRemoved.count) objects from group '$($_.DeviceAzureADGroupName)'. Source group: '$($_.UserAzureADGroupName)'"
                    }
                }
                else {
                    Write-LogRunbook "No devices found for users is user group '$($_.UserAzureADGroupId)'." -Caller "Test-AADSourceGroupMembers"
                }
            }
            else {
                Write-LogRunbook 'This entry contains at least one unsupported OS.' -Caller "Test-OSList"
            }

        }
        $CurrentJsonObject++
    }
    #######################
    #######################
    #######################
    # Main code goes here
    #######################
    #######################
    #######################
    # throw [CustomException]::new( "Get-ErrorOne", "This will cause the script to end with ExitCode 101")
    # some more code
    # throw [CustomException]::new( "Get-ErrorTwo", "This will cause the script to end with ExitCode 102")
}
catch {
    switch ($_.Exception.Message) {
        'Get-GraphToken' { $Global:ExitCode = 101 }
        'Get-JsonContent' { $Global:ExitCode = 102 }
        'Test-AADGroup' { $Global:ExitCode = 103 }
        'Get-AADTransitiveGroupMembers' { $Global:ExitCode = 104 }
        'Get-AADUserOwnedDevices' { $Global:ExitCode = 105 }
        'Add-AADGroupMembers' { $Global:ExitCode = 106 }
        'Remove-AADDirectGroupMember' { $Global:ExitCode = 106 }
        Default { $Global:ExitCode = 300 }
    }
    Write-ErrorRunbook
    Write-LogRunbook "Execution completed with exit code: $Global:ExitCode" -Caller 'Info-End'
}
finally {
    if ($Global:ExitCode -ne 0) { throw $_ }
    Write-LogRunbook "Execution completed with exit code: $Global:ExitCode" -Caller 'Info-End'
}
#EndRegion ----------------------------------------------------- [Main] ----------------------------------------------